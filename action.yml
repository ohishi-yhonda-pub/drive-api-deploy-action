name: 'Drive API Deploy Action'
description: 'Deploy Drive API to public repository and GitHub Pages with OpenAPI generation and coverage reports'
author: 'ohishi-yhonda-org'

inputs:
  github-token:
    description: 'GitHub token for accessing private repository'
    required: true
  public-repo-token:
    description: 'GitHub token for accessing public repository'
    required: true
  private-repo:
    description: 'Private repository (owner/repo)'
    required: true
  public-repo:
    description: 'Public repository (owner/repo)'
    required: true
  wrangler-port:
    description: 'Port for Wrangler dev server'
    required: false
    default: '8787'

runs:
  using: 'composite'
  steps:
    - name: Check bash availability
      id: check-bash
      shell: powershell
      run: |
        try {
          $bashPath = (Get-Command bash -ErrorAction Stop).Source
          Write-Host "Bash found at: $bashPath"
          echo "bash_available=true" >> $env:GITHUB_OUTPUT
        } catch {
          Write-Host "Bash not found, will use PowerShell"
          echo "bash_available=false" >> $env:GITHUB_OUTPUT
        }
    
    - name: Process and Deploy (Bash)
      if: steps.check-bash.outputs.bash_available == 'true'
      shell: bash
      run: |
        # Create temp directory
        tempDir="/tmp/deploy-$(date +%Y%m%d%H%M%S)"
        mkdir -p "$tempDir"
        cd "$tempDir"
        
        # Clone private repository
        git clone "https://x-access-token:${{ inputs.github-token }}@github.com/${{ inputs.private-repo }}.git" private
        cd private
        
        # Install dependencies
        npm install
        
        # Check if wrangler.toml or wrangler.json or wrangler.jsonc exists
        if [ -f wrangler.toml ] || [ -f wrangler.json ] || [ -f wrangler.jsonc ]; then
          echo "Wrangler configuration found, generating OpenAPI specification..."
          
          # Copy template for Wrangler
          if [ -f .dev.vars.template ]; then
            cp .dev.vars.template .dev.vars
          fi
          
          # Start Wrangler and generate OpenAPI
          echo "Starting Wrangler dev server on port ${{ inputs.wrangler-port }}..."
          # Create logs directory
          mkdir -p logs
          # Start Wrangler with output redirection using npm run
          npm run dev -- --port ${{ inputs.wrangler-port }} > logs/wrangler.stdout.log 2> logs/wrangler.stderr.log &
          wranglerPID=$!
          echo "Wrangler started with PID: $wranglerPID"
          sleep 5
          
          # Check if Wrangler process is still running
          if ! ps -p $wranglerPID > /dev/null; then
            echo "ERROR: Wrangler process died immediately!"
            echo "=== Wrangler stdout ==="
            cat logs/wrangler.stdout.log || echo "No stdout log found"
            echo "=== Wrangler stderr ==="
            cat logs/wrangler.stderr.log || echo "No stderr log found"
            echo "===================="
          else
            # Log the actual port being used
            echo "Checking which port Wrangler is using..."
            sleep 3
            
            # Check Wrangler logs for actual port
            actualPort=""
            if [ -f logs/wrangler.stdout.log ]; then
              # Look for common patterns in Wrangler output
              actualPort=$(grep -oE "(Listening on|Local:|Ready on|Server running on).*:([0-9]+)" logs/wrangler.stdout.log 2>/dev/null | grep -oE "[0-9]+" | tail -1)
              if [ -z "$actualPort" ]; then
                # Alternative pattern
                actualPort=$(grep -oE "localhost:([0-9]+)" logs/wrangler.stdout.log 2>/dev/null | grep -oE "[0-9]+" | tail -1)
              fi
            fi
            
            # If not found in logs, check netstat
            if [ -z "$actualPort" ]; then
              actualPort=$(netstat -tlnp 2>/dev/null | grep -E "node|wrangler" | grep -oE ':[0-9]+' | head -1 | cut -d: -f2)
            fi
            
            if [ -n "$actualPort" ]; then
              echo "Wrangler is running on port: $actualPort"
            else
              echo "Could not determine actual port, assuming it's using requested port: ${{ inputs.wrangler-port }}"
              actualPort=${{ inputs.wrangler-port }}
            fi
          fi
          
          # Wait for server and fetch OpenAPI
          maxAttempts=30
          for i in $(seq 1 $maxAttempts); do
            echo "Attempt $i/$maxAttempts: Checking Wrangler at http://localhost:$actualPort/specification"
            
            # Check if process is still running
            if ! ps -p $wranglerPID > /dev/null; then
              echo "ERROR: Wrangler process is no longer running!"
              echo "=== Wrangler stdout (last 50 lines) ==="
              tail -n 50 logs/wrangler.stdout.log || echo "No stdout log found"
              echo "=== Wrangler stderr (last 50 lines) ==="
              tail -n 50 logs/wrangler.stderr.log || echo "No stderr log found"
              echo "===================="
              break
            fi
            
            # Ensure docs directory exists
            mkdir -p docs
            
            # Try to fetch OpenAPI spec with detailed error
            httpStatus=$(curl -w "%{http_code}" -o docs/openapi.json.tmp -s http://localhost:$actualPort/specification 2>&1)
            curlExitCode=$?
            
            if [ $curlExitCode -eq 0 ] && [ "$httpStatus" = "200" ]; then
              mv docs/openapi.json.tmp docs/openapi.json
              echo "SUCCESS: OpenAPI specification generated (HTTP $httpStatus)"
              break
            else
              echo "Failed: curl exit code=$curlExitCode, HTTP status=$httpStatus"
              if [ $curlExitCode -eq 7 ]; then
                echo "Connection refused - Wrangler may not be ready yet"
              elif [ $curlExitCode -ne 0 ]; then
                echo "curl error details: $(curl -v http://localhost:${{ inputs.wrangler-port }}/specification 2>&1 | grep -E 'curl:|Connect')"
              fi
              rm -f docs/openapi.json.tmp
            fi
            
            if [ $i -eq $maxAttempts ]; then
              echo "ERROR: Wrangler failed to respond after $maxAttempts attempts"
              echo "=== Final Wrangler logs ==="
              echo "--- stdout (last 100 lines) ---"
              tail -n 100 logs/wrangler.stdout.log || echo "No stdout log found"
              echo "--- stderr (last 100 lines) ---"
              tail -n 100 logs/wrangler.stderr.log || echo "No stderr log found"
              echo "=== Port check ==="
              netstat -tlnp 2>/dev/null | grep ":${{ inputs.wrangler-port }}" || echo "Port ${{ inputs.wrangler-port }} not found in netstat"
              echo "=== Process check ==="
              ps aux | grep -E "wrangler|worker" | grep -v grep || echo "No wrangler processes found"
              echo "===================="
              echo "Continuing without OpenAPI specification..."
              break
            fi
            sleep 2
          done
          
          # Stop Wrangler
          kill $wranglerPID || true
          rm -f .dev.vars
          
          # Generate Swagger UI in doc directory and move openapi.json to specification
          if [ -f docs/openapi.json ]; then
            mkdir -p docs/doc
            mkdir -p docs/specification
            mv docs/openapi.json docs/specification/
            echo '<!DOCTYPE html>' > docs/doc/index.html
            echo '<html lang="en">' >> docs/doc/index.html
            echo '<head>' >> docs/doc/index.html
            echo '    <meta charset="UTF-8">' >> docs/doc/index.html
            echo '    <title>API Documentation</title>' >> docs/doc/index.html
            echo '    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css">' >> docs/doc/index.html
            echo '</head>' >> docs/doc/index.html
            echo '<body>' >> docs/doc/index.html
            echo '    <div id="swagger-ui"></div>' >> docs/doc/index.html
            echo '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>' >> docs/doc/index.html
            echo '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>' >> docs/doc/index.html
            echo '    <script>' >> docs/doc/index.html
            echo '        window.onload = function() {' >> docs/doc/index.html
            echo '            window.ui = SwaggerUIBundle({' >> docs/doc/index.html
            echo '                url: "../specification/openapi.json",' >> docs/doc/index.html
            echo "                dom_id: '#swagger-ui'," >> docs/doc/index.html
            echo '                deepLinking: true,' >> docs/doc/index.html
            echo '                presets: [' >> docs/doc/index.html
            echo '                    SwaggerUIBundle.presets.apis,' >> docs/doc/index.html
            echo '                    SwaggerUIStandalonePreset' >> docs/doc/index.html
            echo '                ],' >> docs/doc/index.html
            echo '                plugins: [' >> docs/doc/index.html
            echo '                    SwaggerUIBundle.plugins.DownloadUrl' >> docs/doc/index.html
            echo '                ],' >> docs/doc/index.html
            echo '                layout: "StandaloneLayout"' >> docs/doc/index.html
            echo '            });' >> docs/doc/index.html
            echo '        };' >> docs/doc/index.html
            echo '    </script>' >> docs/doc/index.html
            echo '</body>' >> docs/doc/index.html
            echo '</html>' >> docs/doc/index.html
          fi
        else
          echo "No wrangler.toml or wrangler.json or wrangler.jsonc found, skipping OpenAPI generation"
          # Create docs directory if it doesn't exist
          mkdir -p docs
        fi
        
        # Run tests and generate coverage
        npm run test:coverage
        
        # Remove sensitive files
        if [ -f .gitattributes ]; then
          while IFS= read -r line; do
            if [[ $line =~ ^([^[:space:]]+)[[:space:]]+filter=git-crypt ]]; then
              file="${BASH_REMATCH[1]}"
              [ -f "$file" ] && rm -f "$file"
            fi
          done < .gitattributes
          rm -f .gitattributes
        fi
        
        # Configure git for commit
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Get original commit message (single line to avoid issues)
        ORIGINAL_MSG=$(git log -1 --pretty=%s)
        
        # Clone public repository to ensure common history
        cd ..
        echo "Cloning public repository to create branch with common history..."
        git clone "https://x-access-token:${{ inputs.public-repo-token }}@github.com/${{ inputs.public-repo }}.git" public-temp
        cd public-temp
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Create branch name
        BRANCH_NAME="deploy-$(date +%Y%m%d%H%M%S)"
        
        # Create a new branch from main
        git checkout -b $BRANCH_NAME
        
        # Remove all existing files (except .git)
        find . -maxdepth 1 -name .git -prune -o -exec rm -rf {} + 2>/dev/null || true
        
        # Copy files from private repo (excluding .git, .github and sensitive files)
        echo "Copying files from private repository..."
        cp -r ../private/* . 2>/dev/null || true
        cp -r ../private/.[^.]* . 2>/dev/null || true
        
        # Remove .github directory if it was copied
        rm -rf .github
        
        # Add all files
        git add -A
        
        # Check if there are files to commit
        if git diff --cached --quiet; then
          echo "No changes detected. Adding deployment timestamp..."
          # Force a change by adding/updating deployment info
          TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
          echo "# Last deployment" > DEPLOY_INFO.md
          echo "" >> DEPLOY_INFO.md
          echo "Deployed from private repository" >> DEPLOY_INFO.md
          echo "Timestamp: $TIMESTAMP" >> DEPLOY_INFO.md
          echo "Commit: $ORIGINAL_MSG" >> DEPLOY_INFO.md
          git add DEPLOY_INFO.md
        fi
        
        # Commit with original message
        git commit -m "$ORIGINAL_MSG"
        
        # Push to the new branch
        echo "Pushing to branch: $BRANCH_NAME"
        git push origin $BRANCH_NAME
        
        # Create Pull Request using GitHub CLI
        echo "Creating pull request..."
        
        # Configure GitHub CLI
        export GH_TOKEN=${{ inputs.public-repo-token }}
        
        # Create PR directly without cloning
        PR_URL=$(gh pr create --repo ${{ inputs.public-repo }} \
          --base main \
          --head $BRANCH_NAME \
          --title "Deploy from private repository: $ORIGINAL_MSG" \
          --body "$(echo -e "Automated deployment from private repository.\n\nOriginal commit message:\n$ORIGINAL_MSG")" || echo "PR_CREATION_FAILED")
        
        if [ "$PR_URL" = "PR_CREATION_FAILED" ]; then
          echo "Failed to create PR. Checking if branch was pushed successfully..."
          echo "You may need to create the PR manually at: https://github.com/${{ inputs.public-repo }}/pull/new/$BRANCH_NAME"
          echo "Continuing with GitHub Pages deployment..."
        else
          echo "Pull request created: $PR_URL"
          
          # Auto-merge the PR
          echo "Auto-merging pull request..."
          gh pr merge "$PR_URL" --repo ${{ inputs.public-repo }} --merge --delete-branch || echo "Auto-merge failed. Please merge manually."
          
          echo "Pull request process completed!"
        fi
        
        # Deploy to GitHub Pages directly from private repository
        cd ..
        git clone "https://x-access-token:${{ inputs.public-repo-token }}@github.com/${{ inputs.public-repo }}.git" public
        cd public
        
        # Checkout gh-pages branch
        git checkout gh-pages 2>/dev/null || git checkout --orphan gh-pages
        
        # Clear existing content
        find . -maxdepth 1 -name .git -prune -o -exec rm -rf {} + 2>/dev/null || true
        
        # Copy new content
        if [ -d ../private/docs ] && [ "$(ls -A ../private/docs)" ]; then
          cp -r ../private/docs/* .
          cp -r ../private/coverage .
          
          # Create root index.html with links
          echo '<!DOCTYPE html>' > index.html
          echo '<html lang="en">' >> index.html
          echo '<head>' >> index.html
          echo '    <meta charset="UTF-8">' >> index.html
          echo '    <title>Project Documentation</title>' >> index.html
          echo '    <style>' >> index.html
          echo '        body { font-family: Arial, sans-serif; margin: 40px; }' >> index.html
          echo '        h1 { color: #333; }' >> index.html
          echo '        .links { margin-top: 30px; }' >> index.html
          echo '        .link-item { margin: 15px 0; }' >> index.html
          echo '        a { color: #0066cc; text-decoration: none; font-size: 18px; }' >> index.html
          echo '        a:hover { text-decoration: underline; }' >> index.html
          echo '    </style>' >> index.html
          echo '</head>' >> index.html
          echo '<body>' >> index.html
          echo '    <h1>Project Documentation</h1>' >> index.html
          echo '    <div class="links">' >> index.html
          echo '        <div class="link-item">' >> index.html
          echo '            <a href="./doc/">ðŸ“š API Documentation (Swagger UI)</a>' >> index.html
          echo '        </div>' >> index.html
          echo '        <div class="link-item">' >> index.html
          echo '            <a href="./coverage/index.html">ðŸ“Š Test Coverage Report</a>' >> index.html
          echo '        </div>' >> index.html
          echo '    </div>' >> index.html
          echo '</body>' >> index.html
          echo '</html>' >> index.html
          # doc and specification directories already created above if openapi.json exists
        else
          # If no docs (Swagger/OpenAPI), use coverage as root
          cp -r ../private/coverage/* .
        fi
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Commit and push
        git add -A
        git commit -m "Deploy to GitHub Pages"
        git push origin gh-pages --force
        
        # Cleanup
        cd /tmp
        rm -rf "$tempDir"
    
    - name: Setup PowerShell Environment
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        # Find Git and Node.js paths
        $gitPath = ""
        $nodePath = ""
        
        # Common Git paths
        $gitPaths = @(
          "C:\Program Files\Git\cmd",
          "C:\Program Files\Git\bin",
          "C:\Program Files (x86)\Git\cmd",
          "C:\Program Files (x86)\Git\bin",
          "C:\Git\cmd",
          "C:\Git\bin"
        )
        
        # Common Node.js paths
        $nodePaths = @(
          "C:\Program Files\nodejs",
          "C:\Program Files (x86)\nodejs",
          "C:\nodejs"
        )
        
        # Find Git
        foreach ($path in $gitPaths) {
          if (Test-Path "$path\git.exe") {
            $gitPath = $path
            Write-Host "Git found at: $gitPath"
            break
          }
        }
        
        # Find Node.js
        foreach ($path in $nodePaths) {
          if (Test-Path "$path\node.exe") {
            $nodePath = $path
            Write-Host "Node.js found at: $nodePath"
            break
          }
        }
        
        # If not found, try to get from PATH
        if (-not $gitPath) {
          try {
            $gitCmd = Get-Command git -ErrorAction Stop
            $gitPath = Split-Path $gitCmd.Path -Parent
            Write-Host "Git found in PATH at: $gitPath"
          } catch {
            Write-Host "WARNING: Git not found. Will try to use git directly."
          }
        }
        
        if (-not $nodePath) {
          try {
            $nodeCmd = Get-Command node -ErrorAction Stop
            $nodePath = Split-Path $nodeCmd.Path -Parent
            Write-Host "Node.js found in PATH at: $nodePath"
          } catch {
            Write-Host "WARNING: Node.js not found. Will try to use npm directly."
          }
        }
        
        # Add to PATH for this step
        if ($gitPath) {
          $env:PATH = "$gitPath;$env:PATH"
        }
        if ($nodePath) {
          $env:PATH = "$nodePath;$env:PATH"
        }
        
        # Export PATH for subsequent steps
        echo "PATH=$env:PATH" >> $env:GITHUB_ENV
        
        # Create temp directory
        $tempDir = Join-Path $env:TEMP ("deploy-" + (Get-Date -Format "yyyyMMddHHmmss"))
        New-Item -ItemType Directory -Path $tempDir -Force
        
        # Store temp directory for next steps
        echo "TEMP_DEPLOY_DIR=$tempDir" >> $env:GITHUB_ENV
        
        Write-Host "Setup completed. Deploy directory: $tempDir"
    
    - name: Clone and Setup Private Repository
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        cd $env:TEMP_DEPLOY_DIR
        
        # Clone private repository
        $token = "${{ inputs.github-token }}".Trim()
        $repo = "${{ inputs.private-repo }}".Trim()
        $privateRepoUrl = "https://x-access-token:${token}@github.com/${repo}.git"
        Write-Host "Cloning private repository..."
        git clone $privateRepoUrl private
        cd private
        
        # Install dependencies
        npm install
        
        Write-Host "Repository cloned and dependencies installed"
    
    - name: Generate OpenAPI Specification (PowerShell)
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        cd "$env:TEMP_DEPLOY_DIR\private"
        
        # Check if wrangler.toml or wrangler.json or wrangler.jsonc exists
        if ((Test-Path wrangler.toml) -or (Test-Path wrangler.json) -or (Test-Path wrangler.jsonc)) {
          Write-Host "Wrangler configuration found, generating OpenAPI specification..."
          
          # Copy template for Wrangler
          if (Test-Path .dev.vars.template) {
            Copy-Item .dev.vars.template .dev.vars
          }
          
          # Start Wrangler and generate OpenAPI
          Write-Host "Starting Wrangler dev server on port ${{ inputs.wrangler-port }}..."
          # Create logs directory
          New-Item -ItemType Directory -Path logs -Force | Out-Null
          
          # Start Wrangler using PowerShell job with proper output handling
          $currentDir = (Get-Location).Path
          $logsDir = Join-Path $currentDir "logs"
          $stdoutLog = Join-Path $logsDir "wrangler.stdout.log"
          $stderrLog = Join-Path $logsDir "wrangler.stderr.log"
          
          # Start Wrangler using PowerShell job with proper output handling
          Write-Host "Current directory: $currentDir"
          Write-Host "Logs will be written to: $stdoutLog and $stderrLog"
          
          $wranglerJob = Start-Job -ScriptBlock {
            param($workDir, $port)
            Set-Location $workDir
            
            # Ensure npx is in PATH
            $env:PATH = "C:\Program Files\nodejs;$env:PATH"
            
            # Create a separate process for wrangler that doesn't block
            $psi = New-Object System.Diagnostics.ProcessStartInfo
            $psi.FileName = "cmd.exe"
            $psi.Arguments = "/c npm run dev -- --port $port 2>&1"
            $psi.UseShellExecute = $false
            $psi.RedirectStandardOutput = $true
            $psi.RedirectStandardError = $true
            $psi.WorkingDirectory = $workDir
            $psi.CreateNoWindow = $true
            
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $psi
            
            # Register event handlers for output
            $outputBuilder = New-Object System.Text.StringBuilder
            $errorBuilder = New-Object System.Text.StringBuilder
            
            $outputHandler = {
              if ($EventArgs.Data -ne $null) {
                $null = $outputBuilder.AppendLine($EventArgs.Data)
                Write-Host $EventArgs.Data
              }
            }
            
            $errorHandler = {
              if ($EventArgs.Data -ne $null) {
                $null = $errorBuilder.AppendLine($EventArgs.Data)
                Write-Host "ERROR: $($EventArgs.Data)"
              }
            }
            
            Register-ObjectEvent -InputObject $process -EventName "OutputDataReceived" -Action $outputHandler | Out-Null
            Register-ObjectEvent -InputObject $process -EventName "ErrorDataReceived" -Action $errorHandler | Out-Null
            
            # Start the process
            $started = $process.Start()
            $process.BeginOutputReadLine()
            $process.BeginErrorReadLine()
            
            # Save output periodically
            $logsDir = Join-Path $workDir "logs"
            while (!$process.HasExited) {
              Start-Sleep -Seconds 2
              
              # Write current output to files
              if ($outputBuilder.Length -gt 0) {
                $outputBuilder.ToString() | Out-File -FilePath (Join-Path $logsDir "wrangler.stdout.log") -Encoding UTF8
              }
              if ($errorBuilder.Length -gt 0) {
                $errorBuilder.ToString() | Out-File -FilePath (Join-Path $logsDir "wrangler.stderr.log") -Encoding UTF8
              }
            }
            
            # Final write
            $outputBuilder.ToString() | Out-File -FilePath (Join-Path $logsDir "wrangler.stdout.log") -Encoding UTF8
            $errorBuilder.ToString() | Out-File -FilePath (Join-Path $logsDir "wrangler.stderr.log") -Encoding UTF8
            
            return @{
              ExitCode = $process.ExitCode
              Output = $outputBuilder.ToString()
              Error = $errorBuilder.ToString()
            }
          } -ArgumentList $currentDir, ${{ inputs.wrangler-port }}
          
          Write-Host "Wrangler job started with ID: $($wranglerJob.Id)"
          Start-Sleep -Seconds 5
          
          # Check if Wrangler job is still running
          if ($wranglerJob.State -ne "Running") {
            Write-Host "ERROR: Wrangler job terminated with state: $($wranglerJob.State)"
            if (Test-Path logs\wrangler.stdout.log) {
              Write-Host "=== Wrangler stdout ==="
              Get-Content logs\wrangler.stdout.log
            }
            if (Test-Path logs\wrangler.stderr.log) {
              Write-Host "=== Wrangler stderr ==="
              Get-Content logs\wrangler.stderr.log
            }
            Write-Host "===================="
          } else {
            # Log the actual port being used
            Write-Host "Checking which port Wrangler is using..."
            Start-Sleep -Seconds 3
            
            # Check Wrangler logs for actual port
            $actualPort = $null
            if (Test-Path logs\wrangler.stdout.log) {
              # Look for common patterns in Wrangler output
              $logContent = Get-Content logs\wrangler.stdout.log -Raw
              if ($logContent -match "(Listening on|Local:|Ready on|Server running on).*:(\d+)") {
                $actualPort = $matches[2]
              } elseif ($logContent -match "localhost:(\d+)") {
                $actualPort = $matches[1]
              }
            }
            
            # If not found in logs, check netstat
            if (-not $actualPort) {
              try {
                $portInfo = netstat -an | Select-String ":(\d+).*LISTENING" | Where-Object { $_ -match "127\.0\.0\.1:(\d+)" } | ForEach-Object { $matches[1] }
                $nodeProcesses = Get-Process | Where-Object { $_.ProcessName -match "node" }
                if ($nodeProcesses -and $portInfo) {
                  $actualPort = $portInfo | Select-Object -First 1
                }
              } catch {
                Write-Host "Error checking port: $_"
              }
            }
            
            if ($actualPort) {
              Write-Host "Wrangler is running on port: $actualPort"
              # Store in environment for later use
              echo "WRANGLER_ACTUAL_PORT=$actualPort" >> $env:GITHUB_ENV
            } else {
              Write-Host "Could not determine actual port, assuming it's using requested port: ${{ inputs.wrangler-port }}"
              $actualPort = "${{ inputs.wrangler-port }}"
              echo "WRANGLER_ACTUAL_PORT=${{ inputs.wrangler-port }}" >> $env:GITHUB_ENV
            }
          }
          
          # Wait for server and fetch OpenAPI
          $maxAttempts = 30
          for ($i = 1; $i -le $maxAttempts; $i++) {
            Write-Host "Attempt $i/$maxAttempts`: Checking Wrangler at http://localhost:$actualPort/specification"
            
            # Check if job is still running
            if ($wranglerJob.State -ne "Running") {
              Write-Host "ERROR: Wrangler job is no longer running! State: $($wranglerJob.State)"
              # Try to get job results
              try {
                $jobResult = Receive-Job -Job $wranglerJob -ErrorAction Stop
                Write-Host "Job output: $jobResult"
              } catch {
                Write-Host "Could not retrieve job output: $_"
              }
              if (Test-Path logs\wrangler.stdout.log) {
                Write-Host "=== Wrangler stdout (last 50 lines) ==="
                Get-Content logs\wrangler.stdout.log -Tail 50
              }
              if (Test-Path logs\wrangler.stderr.log) {
                Write-Host "=== Wrangler stderr (last 50 lines) ==="
                Get-Content logs\wrangler.stderr.log -Tail 50
              }
              Write-Host "===================="
              break
            }
            
            try {
              # Ensure docs directory exists
              New-Item -ItemType Directory -Path docs -Force | Out-Null
              
              $response = Invoke-WebRequest -Uri "http://localhost:$actualPort/specification" -UseBasicParsing -ErrorAction Stop -TimeoutSec 5
              $response.Content | Out-File -FilePath docs/openapi.json -Encoding UTF8
              Write-Host "SUCCESS: OpenAPI specification generated (HTTP $($response.StatusCode))"
              break
            } catch {
              $errorDetails = $_.Exception.Message
              Write-Host "Failed: $errorDetails"
              
              if ($_.Exception -is [System.Net.WebException]) {
                $webEx = [System.Net.WebException]$_.Exception
                if ($webEx.Status -eq [System.Net.WebExceptionStatus]::ConnectFailure) {
                  Write-Host "Connection refused - Wrangler may not be ready yet"
                } elseif ($webEx.Response) {
                  $statusCode = [int]$webEx.Response.StatusCode
                  Write-Host "HTTP Status Code: $statusCode"
                }
              }
              
              if ($i -eq $maxAttempts) {
                Write-Host "ERROR: Wrangler failed to respond after $maxAttempts attempts"
                Write-Host "=== Final Wrangler logs ==="
                if (Test-Path logs\wrangler.stdout.log) {
                  Write-Host "--- stdout (last 100 lines) ---"
                  Get-Content logs\wrangler.stdout.log -Tail 100
                } else {
                  Write-Host "No stdout log found at logs\wrangler.stdout.log"
                }
                if (Test-Path logs\wrangler.stderr.log) {
                  Write-Host "--- stderr (last 100 lines) ---"
                  Get-Content logs\wrangler.stderr.log -Tail 100
                } else {
                  Write-Host "No stderr log found at logs\wrangler.stderr.log"
                }
                Write-Host "=== Port check ==="
                try {
                  $portCheck = netstat -an | Select-String ":${{ inputs.wrangler-port }}"
                  if ($portCheck) {
                    Write-Host "Port ${{ inputs.wrangler-port }} found in netstat:"
                    $portCheck
                  } else {
                    Write-Host "Port ${{ inputs.wrangler-port }} not found in netstat"
                  }
                } catch {
                  Write-Host "Could not run netstat: $_"
                }
                Write-Host "=== Process check ==="
                Get-Process | Where-Object { $_.ProcessName -match "node|wrangler" } | Format-Table -Property Id, ProcessName, StartTime
                Write-Host "===================="
                Write-Host "Continuing without OpenAPI specification..."
                break
              }
              Start-Sleep -Seconds 2
            }
          }
          
          # Stop Wrangler
          Stop-Job -Job $wranglerJob -ErrorAction SilentlyContinue
          Remove-Job -Job $wranglerJob -Force -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 2
          Remove-Item .dev.vars -Force -ErrorAction SilentlyContinue
          
          # Generate Swagger UI in doc directory and move openapi.json to specification
          if (Test-Path docs/openapi.json) {
            New-Item -ItemType Directory -Path docs/doc -Force | Out-Null
            New-Item -ItemType Directory -Path docs/specification -Force | Out-Null
            Move-Item docs/openapi.json docs/specification/ -Force
            
            # Create Swagger UI HTML
            $swaggerHtml = "<!DOCTYPE html>`n"
            $swaggerHtml += "<html lang='en'>`n"
            $swaggerHtml += "<head>`n"
            $swaggerHtml += "    <meta charset='UTF-8'>`n"
            $swaggerHtml += "    <title>API Documentation</title>`n"
            $swaggerHtml += "    <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css'>`n"
            $swaggerHtml += "</head>`n"
            $swaggerHtml += "<body>`n"
            $swaggerHtml += "    <div id='swagger-ui'></div>`n"
            $swaggerHtml += "    <script src='https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js'></script>`n"
            $swaggerHtml += "    <script src='https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js'></script>`n"
            $swaggerHtml += "    <script>`n"
            $swaggerHtml += "        window.onload = function() {`n"
            $swaggerHtml += "            window.ui = SwaggerUIBundle({`n"
            $swaggerHtml += "                url: '../specification/openapi.json',`n"
            $swaggerHtml += "                dom_id: '#swagger-ui',`n"
            $swaggerHtml += "                deepLinking: true,`n"
            $swaggerHtml += "                presets: [`n"
            $swaggerHtml += "                    SwaggerUIBundle.presets.apis,`n"
            $swaggerHtml += "                    SwaggerUIStandalonePreset`n"
            $swaggerHtml += "                ],`n"
            $swaggerHtml += "                plugins: [`n"
            $swaggerHtml += "                    SwaggerUIBundle.plugins.DownloadUrl`n"
            $swaggerHtml += "                ],`n"
            $swaggerHtml += "                layout: 'StandaloneLayout'`n"
            $swaggerHtml += "            });`n"
            $swaggerHtml += "        };`n"
            $swaggerHtml += "    </script>`n"
            $swaggerHtml += "</body>`n"
            $swaggerHtml += "</html>`n"
            $swaggerHtml | Out-File -FilePath docs/doc/index.html -Encoding UTF8
          }
        } else {
          Write-Host "No wrangler.toml or wrangler.json found, skipping OpenAPI generation"
          # Create docs directory if it doesn't exist
          New-Item -ItemType Directory -Path docs -Force | Out-Null
        }
    
    - name: Run Tests and Deploy (PowerShell)
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        cd "$env:TEMP_DEPLOY_DIR\private"
        
        # Run tests and generate coverage
        npm run test:coverage
        
        # Remove sensitive files
        $filesToRemove = @()
        if (Test-Path .gitattributes) {
          Get-Content .gitattributes | ForEach-Object {
            if ($_ -match '^(.+?)\s+filter=git-crypt') {
              $filesToRemove += $matches[1]
            }
          }
        }
        
        foreach ($file in $filesToRemove) {
          if (Test-Path $file) {
            Remove-Item $file -Force
          }
        }
        Remove-Item .gitattributes -Force -ErrorAction SilentlyContinue
        
        # Configure git for commit
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Get original commit message (single line to avoid issues)
        $originalMsg = git log -1 --pretty=%s
        
        # Store for next step
        echo "ORIGINAL_MSG=$originalMsg" >> $env:GITHUB_ENV
    
    - name: Create PR and Deploy to GitHub Pages (PowerShell)
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        cd "$env:TEMP_DEPLOY_DIR"
        
        # Clone public repository to ensure common history
        Write-Host "Cloning public repository to create branch with common history..."
        $publicToken = "${{ inputs.public-repo-token }}".Trim()
        $publicRepo = "${{ inputs.public-repo }}".Trim()
        $publicRepoUrl = "https://x-access-token:${publicToken}@github.com/${publicRepo}.git"
        git clone $publicRepoUrl public-temp
        cd public-temp
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Create branch name
        $branchName = "deploy-" + (Get-Date -Format "yyyyMMddHHmmss")
        
        # Create a new branch from main
        git checkout -b $branchName
        
        # Remove all existing files (except .git)
        Get-ChildItem -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
        
        # Copy files from private repo (excluding .git, .github and sensitive files)
        Write-Host "Copying files from private repository..."
        Copy-Item -Path ../private/* -Destination . -Recurse -Force -Exclude .git
        
        # Remove .github directory if it was copied
        if (Test-Path .github) {
          Remove-Item .github -Recurse -Force
        }
        
        # Add all files
        git add -A
        
        # Check if there are files to commit
        $hasChanges = git diff --cached --quiet; $lastExitCode -ne 0
        if (-not $hasChanges) {
          Write-Host "No changes detected. Adding deployment timestamp..."
          # Force a change by adding/updating deployment info
          $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
          $deployInfo = "# Last deployment`n`nDeployed from private repository`nTimestamp: $timestamp`nCommit: $env:ORIGINAL_MSG"
          $deployInfo | Out-File DEPLOY_INFO.md
          git add DEPLOY_INFO.md
          $hasChanges = $true
        }
        
        # Commit with original message
        git commit -m "$env:ORIGINAL_MSG"
        
        # Push to the new branch
        Write-Host "Pushing to branch: $branchName"
        git push origin $branchName
        
        # Create Pull Request using GitHub API
        Write-Host "Creating pull request..."
        
        # Use GitHub API to create PR
        try {
          $headers = @{
            "Authorization" = "Bearer ${{ inputs.public-repo-token }}"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          $body = @{
            "title" = "Deploy from private repository: $env:ORIGINAL_MSG"
            "body" = "Automated deployment from private repository.`n`nOriginal commit message:`n$env:ORIGINAL_MSG"
            "head" = $branchName
            "base" = "main"
          } | ConvertTo-Json
          
          $apiUrl = "https://api.github.com/repos/${{ inputs.public-repo }}/pulls"
          
          Write-Host "Creating PR via API: $apiUrl"
          $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body -ContentType "application/json"
          
          if ($response -and $response.html_url) {
            Write-Host "Pull request created: $($response.html_url)"
            
            # Auto-merge the PR using API
            Write-Host "Auto-merging pull request..."
            try {
              $mergeUrl = "https://api.github.com/repos/${{ inputs.public-repo }}/pulls/$($response.number)/merge"
              $mergeBody = @{
                "commit_title" = "Merge pull request #$($response.number)"
                "commit_message" = "Auto-merge deployment PR"
                "merge_method" = "merge"
              } | ConvertTo-Json
              
              $mergeResponse = Invoke-RestMethod -Uri $mergeUrl -Method Put -Headers $headers -Body $mergeBody -ContentType "application/json"
              Write-Host "Pull request merged successfully!"
            } catch {
              Write-Host "Auto-merge failed. Please merge manually. Error: $_"
            }
          } else {
            throw "PR creation failed - no URL returned"
          }
        } catch {
          Write-Host "Failed to create PR via API. Error: $_"
          Write-Host "You may need to create the PR manually at: https://github.com/${{ inputs.public-repo }}/pull/new/$branchName"
          Write-Host "Continuing with GitHub Pages deployment..."
        }
        
        # Deploy to GitHub Pages
        cd ..
        git clone $publicRepoUrl public
        cd public
        
        # Checkout gh-pages branch
        try {
          git checkout gh-pages 2>$null
        } catch {
          git checkout --orphan gh-pages
        }
        
        # Clear existing content
        Get-ChildItem -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
        
        # Copy new content
        if ((Test-Path ../private/docs) -and (Get-ChildItem ../private/docs -Force)) {
          Copy-Item -Recurse ../private/docs/* .
          Copy-Item -Recurse ../private/coverage .
          
          # Create root index.html with links
          $indexHtml = "<!DOCTYPE html>`n"
          $indexHtml += "<html lang='en'>`n"
          $indexHtml += "<head>`n"
          $indexHtml += "    <meta charset='UTF-8'>`n"
          $indexHtml += "    <title>Project Documentation</title>`n"
          $indexHtml += "    <style>`n"
          $indexHtml += "        body { font-family: Arial, sans-serif; margin: 40px; }`n"
          $indexHtml += "        h1 { color: #333; }`n"
          $indexHtml += "        .links { margin-top: 30px; }`n"
          $indexHtml += "        .link-item { margin: 15px 0; }`n"
          $indexHtml += "        a { color: #0066cc; text-decoration: none; font-size: 18px; }`n"
          $indexHtml += "        a:hover { text-decoration: underline; }`n"
          $indexHtml += "    </style>`n"
          $indexHtml += "</head>`n"
          $indexHtml += "<body>`n"
          $indexHtml += "    <h1>Project Documentation</h1>`n"
          $indexHtml += "    <div class='links'>`n"
          $indexHtml += "        <div class='link-item'>`n"
          $indexHtml += "            <a href='./doc/'>ðŸ“š API Documentation (Swagger UI)</a>`n"
          $indexHtml += "        </div>`n"
          $indexHtml += "        <div class='link-item'>`n"
          $indexHtml += "            <a href='./coverage/index.html'>ðŸ“Š Test Coverage Report</a>`n"
          $indexHtml += "        </div>`n"
          $indexHtml += "    </div>`n"
          $indexHtml += "</body>`n"
          $indexHtml += "</html>`n"
          $indexHtml | Out-File -FilePath index.html -Encoding UTF8
        } else {
          # If no docs (Swagger/OpenAPI), use coverage as root
          Copy-Item -Recurse ../private/coverage/* .
        }
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Commit and push
        git add -A
        git commit -m "Deploy to GitHub Pages"
        git push origin gh-pages --force
        
        # Cleanup
        cd $env:TEMP
        Start-Sleep -Seconds 3
        Remove-Item -Recurse -Force $env:TEMP_DEPLOY_DIR -ErrorAction SilentlyContinue
        
        Write-Host "Deployment completed successfully!"

name: 'Drive API Deploy Action'
description: 'Deploy Drive API to public repository and GitHub Pages with OpenAPI generation and coverage reports'
author: 'ohishi-yhonda-org'

inputs:
  github-token:
    description: 'GitHub token for accessing private repository'
    required: true
  public-repo-token:
    description: 'GitHub token for accessing public repository'
    required: true
  private-repo:
    description: 'Private repository (owner/repo)'
    required: true
  public-repo:
    description: 'Public repository (owner/repo)'
    required: true
  wrangler-port:
    description: 'Port for Wrangler dev server'
    required: false
    default: '8787'

runs:
  using: 'composite'
  steps:
    - name: Check bash availability
      id: check-bash
      shell: powershell
      run: |
        try {
          $bashPath = (Get-Command bash -ErrorAction Stop).Source
          Write-Host "Bash found at: $bashPath"
          echo "bash_available=true" >> $env:GITHUB_OUTPUT
        } catch {
          Write-Host "Bash not found, will use PowerShell"
          echo "bash_available=false" >> $env:GITHUB_OUTPUT
        }
    
    - name: Process and Deploy (Bash)
      if: steps.check-bash.outputs.bash_available == 'true'
      shell: bash
      run: |
        # Create temp directory
        tempDir="/tmp/deploy-$(date +%Y%m%d%H%M%S)"
        mkdir -p "$tempDir"
        cd "$tempDir"
        
        # Clone private repository
        git clone "https://x-access-token:${{ inputs.github-token }}@github.com/${{ inputs.private-repo }}.git" private
        cd private
        
        # Install dependencies
        npm install
        
        # Check if wrangler.toml or wrangler.json or wrangler.jsonc exists
        if [ -f wrangler.toml ] || [ -f wrangler.json ] || [ -f wrangler.jsonc ]; then
          echo "Wrangler configuration found, generating OpenAPI specification..."
          
          # Copy template for Wrangler
          if [ -f .dev.vars.template ]; then
            cp .dev.vars.template .dev.vars
          fi
          
          # Start Wrangler and generate OpenAPI
          echo "Starting Wrangler dev server on port ${{ inputs.wrangler-port }}..."
          # Create logs directory
          mkdir -p logs
          # Start Wrangler with output redirection
          npx wrangler dev --port ${{ inputs.wrangler-port }} --local > logs/wrangler.stdout.log 2> logs/wrangler.stderr.log &
          wranglerPID=$!
          echo "Wrangler started with PID: $wranglerPID"
          sleep 5
          
          # Check if Wrangler process is still running
          if ! ps -p $wranglerPID > /dev/null; then
            echo "ERROR: Wrangler process died immediately!"
            echo "=== Wrangler stdout ==="
            cat logs/wrangler.stdout.log || echo "No stdout log found"
            echo "=== Wrangler stderr ==="
            cat logs/wrangler.stderr.log || echo "No stderr log found"
            echo "===================="
          fi
          
          # Wait for server and fetch OpenAPI
          maxAttempts=30
          for i in $(seq 1 $maxAttempts); do
            echo "Attempt $i/$maxAttempts: Checking Wrangler at http://localhost:${{ inputs.wrangler-port }}/specification"
            
            # Check if process is still running
            if ! ps -p $wranglerPID > /dev/null; then
              echo "ERROR: Wrangler process is no longer running!"
              echo "=== Wrangler stdout (last 50 lines) ==="
              tail -n 50 logs/wrangler.stdout.log || echo "No stdout log found"
              echo "=== Wrangler stderr (last 50 lines) ==="
              tail -n 50 logs/wrangler.stderr.log || echo "No stderr log found"
              echo "===================="
              break
            fi
            
            # Try to fetch OpenAPI spec with detailed error
            httpStatus=$(curl -w "%{http_code}" -o docs/openapi.json.tmp -s http://localhost:${{ inputs.wrangler-port }}/specification 2>&1)
            curlExitCode=$?
            
            if [ $curlExitCode -eq 0 ] && [ "$httpStatus" = "200" ]; then
              mv docs/openapi.json.tmp docs/openapi.json
              echo "SUCCESS: OpenAPI specification generated (HTTP $httpStatus)"
              break
            else
              echo "Failed: curl exit code=$curlExitCode, HTTP status=$httpStatus"
              if [ $curlExitCode -eq 7 ]; then
                echo "Connection refused - Wrangler may not be ready yet"
              elif [ $curlExitCode -ne 0 ]; then
                echo "curl error details: $(curl -v http://localhost:${{ inputs.wrangler-port }}/specification 2>&1 | grep -E 'curl:|Connect')"
              fi
              rm -f docs/openapi.json.tmp
            fi
            
            if [ $i -eq $maxAttempts ]; then
              echo "ERROR: Wrangler failed to respond after $maxAttempts attempts"
              echo "=== Final Wrangler logs ==="
              echo "--- stdout (last 100 lines) ---"
              tail -n 100 logs/wrangler.stdout.log || echo "No stdout log found"
              echo "--- stderr (last 100 lines) ---"
              tail -n 100 logs/wrangler.stderr.log || echo "No stderr log found"
              echo "=== Port check ==="
              netstat -tlnp 2>/dev/null | grep ":${{ inputs.wrangler-port }}" || echo "Port ${{ inputs.wrangler-port }} not found in netstat"
              echo "=== Process check ==="
              ps aux | grep -E "wrangler|worker" | grep -v grep || echo "No wrangler processes found"
              echo "===================="
              echo "Continuing without OpenAPI specification..."
              break
            fi
            sleep 2
          done
          
          # Stop Wrangler
          kill $wranglerPID || true
          rm -f .dev.vars
          
          # Generate Swagger UI in doc directory and move openapi.json to specification
          if [ -f docs/openapi.json ]; then
            mkdir -p docs/doc
            mkdir -p docs/specification
            mv docs/openapi.json docs/specification/
            echo '<!DOCTYPE html>' > docs/doc/index.html
            echo '<html lang="en">' >> docs/doc/index.html
            echo '<head>' >> docs/doc/index.html
            echo '    <meta charset="UTF-8">' >> docs/doc/index.html
            echo '    <title>API Documentation</title>' >> docs/doc/index.html
            echo '    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css">' >> docs/doc/index.html
            echo '</head>' >> docs/doc/index.html
            echo '<body>' >> docs/doc/index.html
            echo '    <div id="swagger-ui"></div>' >> docs/doc/index.html
            echo '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>' >> docs/doc/index.html
            echo '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>' >> docs/doc/index.html
            echo '    <script>' >> docs/doc/index.html
            echo '        window.onload = function() {' >> docs/doc/index.html
            echo '            window.ui = SwaggerUIBundle({' >> docs/doc/index.html
            echo '                url: "../specification/openapi.json",' >> docs/doc/index.html
            echo "                dom_id: '#swagger-ui'," >> docs/doc/index.html
            echo '                deepLinking: true,' >> docs/doc/index.html
            echo '                presets: [' >> docs/doc/index.html
            echo '                    SwaggerUIBundle.presets.apis,' >> docs/doc/index.html
            echo '                    SwaggerUIStandalonePreset' >> docs/doc/index.html
            echo '                ],' >> docs/doc/index.html
            echo '                plugins: [' >> docs/doc/index.html
            echo '                    SwaggerUIBundle.plugins.DownloadUrl' >> docs/doc/index.html
            echo '                ],' >> docs/doc/index.html
            echo '                layout: "StandaloneLayout"' >> docs/doc/index.html
            echo '            });' >> docs/doc/index.html
            echo '        };' >> docs/doc/index.html
            echo '    </script>' >> docs/doc/index.html
            echo '</body>' >> docs/doc/index.html
            echo '</html>' >> docs/doc/index.html
          fi
        else
          echo "No wrangler.toml or wrangler.json or wrangler.jsonc found, skipping OpenAPI generation"
          # Create docs directory if it doesn't exist
          mkdir -p docs
        fi
        
        # Run tests and generate coverage
        npm run test:coverage
        
        # Remove sensitive files
        if [ -f .gitattributes ]; then
          while IFS= read -r line; do
            if [[ $line =~ ^([^[:space:]]+)[[:space:]]+filter=git-crypt ]]; then
              file="${BASH_REMATCH[1]}"
              [ -f "$file" ] && rm -f "$file"
            fi
          done < .gitattributes
          rm -f .gitattributes
        fi
        
        # Configure git for commit
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Get original commit message (single line to avoid issues)
        ORIGINAL_MSG=$(git log -1 --pretty=%s)
        
        # Clone public repository to ensure common history
        cd ..
        echo "Cloning public repository to create branch with common history..."
        git clone "https://x-access-token:${{ inputs.public-repo-token }}@github.com/${{ inputs.public-repo }}.git" public-temp
        cd public-temp
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Create branch name
        BRANCH_NAME="deploy-$(date +%Y%m%d%H%M%S)"
        
        # Create a new branch from main
        git checkout -b $BRANCH_NAME
        
        # Remove all existing files (except .git)
        find . -maxdepth 1 -name .git -prune -o -exec rm -rf {} + 2>/dev/null || true
        
        # Copy files from private repo (excluding .git, .github and sensitive files)
        echo "Copying files from private repository..."
        cp -r ../private/* . 2>/dev/null || true
        cp -r ../private/.[^.]* . 2>/dev/null || true
        
        # Remove .github directory if it was copied
        rm -rf .github
        
        # Add all files
        git add -A
        
        # Check if there are files to commit
        if git diff --cached --quiet; then
          echo "No changes detected. Adding deployment timestamp..."
          # Force a change by adding/updating deployment info
          TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
          echo "# Last deployment" > DEPLOY_INFO.md
          echo "" >> DEPLOY_INFO.md
          echo "Deployed from private repository" >> DEPLOY_INFO.md
          echo "Timestamp: $TIMESTAMP" >> DEPLOY_INFO.md
          echo "Commit: $ORIGINAL_MSG" >> DEPLOY_INFO.md
          git add DEPLOY_INFO.md
        fi
        
        # Commit with original message
        git commit -m "$ORIGINAL_MSG"
        
        # Push to the new branch
        echo "Pushing to branch: $BRANCH_NAME"
        git push origin $BRANCH_NAME
        
        # Create Pull Request using GitHub CLI
        echo "Creating pull request..."
        
        # Configure GitHub CLI
        export GH_TOKEN=${{ inputs.public-repo-token }}
        
        # Create PR directly without cloning
        PR_URL=$(gh pr create --repo ${{ inputs.public-repo }} \
          --base main \
          --head $BRANCH_NAME \
          --title "Deploy from private repository: $ORIGINAL_MSG" \
          --body "$(echo -e "Automated deployment from private repository.\n\nOriginal commit message:\n$ORIGINAL_MSG")" || echo "PR_CREATION_FAILED")
        
        if [ "$PR_URL" = "PR_CREATION_FAILED" ]; then
          echo "Failed to create PR. Checking if branch was pushed successfully..."
          echo "You may need to create the PR manually at: https://github.com/${{ inputs.public-repo }}/pull/new/$BRANCH_NAME"
          echo "Continuing with GitHub Pages deployment..."
        else
          echo "Pull request created: $PR_URL"
          
          # Auto-merge the PR
          echo "Auto-merging pull request..."
          gh pr merge "$PR_URL" --repo ${{ inputs.public-repo }} --merge --delete-branch || echo "Auto-merge failed. Please merge manually."
          
          echo "Pull request process completed!"
        fi
        
        # Deploy to GitHub Pages directly from private repository
        cd ..
        git clone "https://x-access-token:${{ inputs.public-repo-token }}@github.com/${{ inputs.public-repo }}.git" public
        cd public
        
        # Checkout gh-pages branch
        git checkout gh-pages 2>/dev/null || git checkout --orphan gh-pages
        
        # Clear existing content
        find . -maxdepth 1 -name .git -prune -o -exec rm -rf {} + 2>/dev/null || true
        
        # Copy new content
        if [ -d ../private/docs ] && [ "$(ls -A ../private/docs)" ]; then
          cp -r ../private/docs/* .
          cp -r ../private/coverage .
          
          # Create root index.html with links
          echo '<!DOCTYPE html>' > index.html
          echo '<html lang="en">' >> index.html
          echo '<head>' >> index.html
          echo '    <meta charset="UTF-8">' >> index.html
          echo '    <title>Project Documentation</title>' >> index.html
          echo '    <style>' >> index.html
          echo '        body { font-family: Arial, sans-serif; margin: 40px; }' >> index.html
          echo '        h1 { color: #333; }' >> index.html
          echo '        .links { margin-top: 30px; }' >> index.html
          echo '        .link-item { margin: 15px 0; }' >> index.html
          echo '        a { color: #0066cc; text-decoration: none; font-size: 18px; }' >> index.html
          echo '        a:hover { text-decoration: underline; }' >> index.html
          echo '    </style>' >> index.html
          echo '</head>' >> index.html
          echo '<body>' >> index.html
          echo '    <h1>Project Documentation</h1>' >> index.html
          echo '    <div class="links">' >> index.html
          echo '        <div class="link-item">' >> index.html
          echo '            <a href="./doc/">ðŸ“š API Documentation (Swagger UI)</a>' >> index.html
          echo '        </div>' >> index.html
          echo '        <div class="link-item">' >> index.html
          echo '            <a href="./coverage/index.html">ðŸ“Š Test Coverage Report</a>' >> index.html
          echo '        </div>' >> index.html
          echo '    </div>' >> index.html
          echo '</body>' >> index.html
          echo '</html>' >> index.html
          # doc and specification directories already created above if openapi.json exists
        else
          # If no docs (Swagger/OpenAPI), use coverage as root
          cp -r ../private/coverage/* .
        fi
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Commit and push
        git add -A
        git commit -m "Deploy to GitHub Pages"
        git push origin gh-pages --force
        
        # Cleanup
        cd /tmp
        rm -rf "$tempDir"
    
    - name: Process and Deploy (PowerShell)
      if: steps.check-bash.outputs.bash_available == 'false'
      shell: powershell
      run: |
        # Add Git and Node.js to PATH
        $env:PATH = "C:\Program Files\Git\cmd;C:\Program Files\nodejs;$env:PATH"
        
        # Create temp directory
        $tempDir = Join-Path $env:TEMP ("deploy-" + (Get-Date -Format "yyyyMMddHHmmss"))
        New-Item -ItemType Directory -Path $tempDir -Force
        cd $tempDir
        
        # Clone private repository
        $token = "${{ inputs.github-token }}".Trim()
        $repo = "${{ inputs.private-repo }}".Trim()
        $privateRepoUrl = "https://x-access-token:${token}@github.com/${repo}.git"
        Write-Host "Cloning private repository..."
        git clone $privateRepoUrl private
        cd private
        
        # Install dependencies
        npm install
        
        # Check if wrangler.toml or wrangler.json or wrangler.jsonc exists
        if ((Test-Path wrangler.toml) -or (Test-Path wrangler.json) -or (Test-Path wrangler.jsonc)) {
          Write-Host "Wrangler configuration found, generating OpenAPI specification..."
          
          # Copy template for Wrangler
          if (Test-Path .dev.vars.template) {
            Copy-Item .dev.vars.template .dev.vars
          }
          
          # Start Wrangler and generate OpenAPI
          Write-Host "Starting Wrangler dev server on port ${{ inputs.wrangler-port }}..."
          # Create logs directory
          New-Item -ItemType Directory -Path logs -Force | Out-Null
          
          # Start Wrangler with output capture
          $wranglerJob = Start-Job -ScriptBlock {
            param($workDir, $port)
            Set-Location $workDir
            $proc = Start-Process -FilePath "npx" -ArgumentList "wrangler", "dev", "--port", $port, "--local" -NoNewWindow -PassThru -RedirectStandardOutput "logs\wrangler.stdout.log" -RedirectStandardError "logs\wrangler.stderr.log"
            $proc.WaitForExit()
            return $proc.ExitCode
          } -ArgumentList (Get-Location).Path, ${{ inputs.wrangler-port }}
          
          Write-Host "Wrangler job started with ID: $($wranglerJob.Id)"
          Start-Sleep -Seconds 5
          
          # Check if Wrangler job is still running
          if ($wranglerJob.State -ne "Running") {
            Write-Host "ERROR: Wrangler job terminated with state: $($wranglerJob.State)"
            if (Test-Path logs\wrangler.stdout.log) {
              Write-Host "=== Wrangler stdout ==="
              Get-Content logs\wrangler.stdout.log
            }
            if (Test-Path logs\wrangler.stderr.log) {
              Write-Host "=== Wrangler stderr ==="
              Get-Content logs\wrangler.stderr.log
            }
            Write-Host "===================="
          }
          
          # Wait for server and fetch OpenAPI
          $maxAttempts = 30
          for ($i = 1; $i -le $maxAttempts; $i++) {
            Write-Host "Attempt $i/$maxAttempts`: Checking Wrangler at http://localhost:${{ inputs.wrangler-port }}/specification"
            
            # Check if job is still running
            if ($wranglerJob.State -ne "Running") {
              Write-Host "ERROR: Wrangler job is no longer running! State: $($wranglerJob.State)"
              # Try to get job results
              try {
                $jobResult = Receive-Job -Job $wranglerJob -ErrorAction Stop
                Write-Host "Job output: $jobResult"
              } catch {
                Write-Host "Could not retrieve job output: $_"
              }
              if (Test-Path logs\wrangler.stdout.log) {
                Write-Host "=== Wrangler stdout (last 50 lines) ==="
                Get-Content logs\wrangler.stdout.log -Tail 50
              }
              if (Test-Path logs\wrangler.stderr.log) {
                Write-Host "=== Wrangler stderr (last 50 lines) ==="
                Get-Content logs\wrangler.stderr.log -Tail 50
              }
              Write-Host "===================="
              break
            }
            
            try {
              $response = Invoke-WebRequest -Uri "http://localhost:${{ inputs.wrangler-port }}/specification" -UseBasicParsing -ErrorAction Stop -TimeoutSec 5
              $response.Content | Out-File -FilePath docs/openapi.json -Encoding UTF8
              Write-Host "SUCCESS: OpenAPI specification generated (HTTP $($response.StatusCode))"
              break
            } catch {
              $errorDetails = $_.Exception.Message
              Write-Host "Failed: $errorDetails"
              
              if ($_.Exception -is [System.Net.WebException]) {
                $webEx = [System.Net.WebException]$_.Exception
                if ($webEx.Status -eq [System.Net.WebExceptionStatus]::ConnectFailure) {
                  Write-Host "Connection refused - Wrangler may not be ready yet"
                } elseif ($webEx.Response) {
                  $statusCode = [int]$webEx.Response.StatusCode
                  Write-Host "HTTP Status Code: $statusCode"
                }
              }
              
              if ($i -eq $maxAttempts) {
                Write-Host "ERROR: Wrangler failed to respond after $maxAttempts attempts"
                Write-Host "=== Final Wrangler logs ==="
                if (Test-Path logs\wrangler.stdout.log) {
                  Write-Host "--- stdout (last 100 lines) ---"
                  Get-Content logs\wrangler.stdout.log -Tail 100
                } else {
                  Write-Host "No stdout log found at logs\wrangler.stdout.log"
                }
                if (Test-Path logs\wrangler.stderr.log) {
                  Write-Host "--- stderr (last 100 lines) ---"
                  Get-Content logs\wrangler.stderr.log -Tail 100
                } else {
                  Write-Host "No stderr log found at logs\wrangler.stderr.log"
                }
                Write-Host "=== Port check ==="
                try {
                  $portCheck = netstat -an | Select-String ":${{ inputs.wrangler-port }}"
                  if ($portCheck) {
                    Write-Host "Port ${{ inputs.wrangler-port }} found in netstat:"
                    $portCheck
                  } else {
                    Write-Host "Port ${{ inputs.wrangler-port }} not found in netstat"
                  }
                } catch {
                  Write-Host "Could not run netstat: $_"
                }
                Write-Host "=== Process check ==="
                Get-Process | Where-Object { $_.ProcessName -match "node|wrangler" } | Format-Table -Property Id, ProcessName, StartTime
                Write-Host "===================="
                Write-Host "Continuing without OpenAPI specification..."
                break
              }
              Start-Sleep -Seconds 2
            }
          }
          
          # Stop Wrangler
          Stop-Job -Job $wranglerJob -ErrorAction SilentlyContinue
          Remove-Job -Job $wranglerJob -Force -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 2
          Remove-Item .dev.vars -Force -ErrorAction SilentlyContinue
          
          # Generate Swagger UI in doc directory and move openapi.json to specification
          if (Test-Path docs/openapi.json) {
            New-Item -ItemType Directory -Path docs/doc -Force | Out-Null
            New-Item -ItemType Directory -Path docs/specification -Force | Out-Null
            Move-Item docs/openapi.json docs/specification/ -Force
            "<!DOCTYPE html>" | Out-File -FilePath docs/doc/index.html -Encoding UTF8
            '<html lang="en">' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '<head>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <meta charset="UTF-8">' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <title>API Documentation</title>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui.css">' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '</head>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '<body>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <div id="swagger-ui"></div>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-bundle.js"></script>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5/swagger-ui-standalone-preset.js"></script>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    <script>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '        window.onload = function() {' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '            window.ui = SwaggerUIBundle({' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                url: "../specification/openapi.json",' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            "                dom_id: '#swagger-ui'," | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                deepLinking: true,' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                presets: [' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                    SwaggerUIBundle.presets.apis,' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                    SwaggerUIStandalonePreset' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                ],' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                plugins: [' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                    SwaggerUIBundle.plugins.DownloadUrl' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                ],' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '                layout: "StandaloneLayout"' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '            });' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '        };' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '    </script>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '</body>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
            '</html>' | Out-File -FilePath docs/doc/index.html -Append -Encoding UTF8
          }
        } else {
          Write-Host "No wrangler.toml or wrangler.json found, skipping OpenAPI generation"
          # Create docs directory if it doesn't exist
          New-Item -ItemType Directory -Path docs -Force | Out-Null
        }
        
        # Run tests and generate coverage
        npm run test:coverage
        
        # Remove sensitive files
        $filesToRemove = @()
        if (Test-Path .gitattributes) {
          Get-Content .gitattributes | ForEach-Object {
            if ($_ -match '^(.+?)\s+filter=git-crypt') {
              $filesToRemove += $matches[1]
            }
          }
        }
        
        foreach ($file in $filesToRemove) {
          if (Test-Path $file) {
            Remove-Item $file -Force
          }
        }
        Remove-Item .gitattributes -Force -ErrorAction SilentlyContinue
        
        # Configure git for commit
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Get original commit message (single line to avoid issues)
        $originalMsg = git log -1 --pretty=%s
        
        # Clone public repository to ensure common history
        cd ..
        Write-Host "Cloning public repository to create branch with common history..."
        $publicToken = "${{ inputs.public-repo-token }}".Trim()
        $publicRepo = "${{ inputs.public-repo }}".Trim()
        $publicRepoUrl = "https://x-access-token:${publicToken}@github.com/${publicRepo}.git"
        git clone $publicRepoUrl public-temp
        cd public-temp
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Create branch name
        $branchName = "deploy-" + (Get-Date -Format "yyyyMMddHHmmss")
        
        # Create a new branch from main
        git checkout -b $branchName
        
        # Remove all existing files (except .git)
        Get-ChildItem -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
        
        # Copy files from private repo (excluding .git, .github and sensitive files)
        Write-Host "Copying files from private repository..."
        Copy-Item -Path ../private/* -Destination . -Recurse -Force -Exclude .git
        
        # Remove .github directory if it was copied
        if (Test-Path .github) {
          Remove-Item .github -Recurse -Force
        }
        
        # Add all files
        git add -A
        
        # Check if there are files to commit
        $hasChanges = git diff --cached --quiet; $lastExitCode -ne 0
        if (-not $hasChanges) {
          Write-Host "No changes detected. Adding deployment timestamp..."
          # Force a change by adding/updating deployment info
          $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
          $deployInfo = "# Last deployment`n`nDeployed from private repository`nTimestamp: $timestamp`nCommit: $originalMsg"
          $deployInfo | Out-File DEPLOY_INFO.md
          git add DEPLOY_INFO.md
          $hasChanges = $true
        }
        
        # Commit with original message
        git commit -m "$originalMsg"
        
        # Push to the new branch
        Write-Host "Pushing to branch: $branchName"
        git push origin $branchName
        
        # Create Pull Request using GitHub API
        Write-Host "Creating pull request..."
        
        # Use GitHub API to create PR
        try {
          $headers = @{
            "Authorization" = "Bearer ${{ inputs.public-repo-token }}"
            "Accept" = "application/vnd.github.v3+json"
          }
          
          $body = @{
            "title" = "Deploy from private repository: $originalMsg"
            "body" = "Automated deployment from private repository.`n`nOriginal commit message:`n$originalMsg"
            "head" = $branchName
            "base" = "main"
          } | ConvertTo-Json
          
          $apiUrl = "https://api.github.com/repos/${{ inputs.public-repo }}/pulls"
          
          Write-Host "Creating PR via API: $apiUrl"
          $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body -ContentType "application/json"
          
          if ($response -and $response.html_url) {
            Write-Host "Pull request created: $($response.html_url)"
            
            # Auto-merge the PR using API
            Write-Host "Auto-merging pull request..."
            try {
              $mergeUrl = "https://api.github.com/repos/${{ inputs.public-repo }}/pulls/$($response.number)/merge"
              $mergeBody = @{
                "commit_title" = "Merge pull request #$($response.number)"
                "commit_message" = "Auto-merge deployment PR"
                "merge_method" = "merge"
              } | ConvertTo-Json
              
              $mergeResponse = Invoke-RestMethod -Uri $mergeUrl -Method Put -Headers $headers -Body $mergeBody -ContentType "application/json"
              Write-Host "Pull request merged successfully!"
            } catch {
              Write-Host "Auto-merge failed. Please merge manually. Error: $_"
            }
          } else {
            throw "PR creation failed - no URL returned"
          }
        } catch {
          Write-Host "Failed to create PR via API. Error: $_"
          Write-Host "You may need to create the PR manually at: https://github.com/${{ inputs.public-repo }}/pull/new/$branchName"
          Write-Host "Continuing with GitHub Pages deployment..."
        }
        
        # Deploy to GitHub Pages directly from private repository
        cd ..
        $publicToken2 = "${{ inputs.public-repo-token }}".Trim()
        $publicRepo2 = "${{ inputs.public-repo }}".Trim()
        $publicRepoUrl2 = "https://x-access-token:${publicToken2}@github.com/${publicRepo2}.git"
        git clone $publicRepoUrl2 public
        cd public
        
        # Checkout gh-pages branch
        try {
          git checkout gh-pages 2>$null
        } catch {
          git checkout --orphan gh-pages
        }
        
        # Clear existing content
        Get-ChildItem -Force | Where-Object { $_.Name -ne '.git' } | Remove-Item -Recurse -Force
        
        # Copy new content
        if ((Test-Path ../private/docs) -and (Get-ChildItem ../private/docs -Force)) {
          Copy-Item -Recurse ../private/docs/* .
          Copy-Item -Recurse ../private/coverage .
          
          # Create root index.html with links
          '<!DOCTYPE html>' | Out-File -FilePath index.html -Encoding UTF8
          '<html lang="en">' | Out-File -FilePath index.html -Append -Encoding UTF8
          '<head>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    <meta charset="UTF-8">' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    <title>Project Documentation</title>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    <style>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        body { font-family: Arial, sans-serif; margin: 40px; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        h1 { color: #333; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        .links { margin-top: 30px; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        .link-item { margin: 15px 0; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        a { color: #0066cc; text-decoration: none; font-size: 18px; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        a:hover { text-decoration: underline; }' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    </style>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '</head>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '<body>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    <h1>Project Documentation</h1>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    <div class="links">' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        <div class="link-item">' | Out-File -FilePath index.html -Append -Encoding UTF8
          '            <a href="./doc/">ðŸ“š API Documentation (Swagger UI)</a>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        </div>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        <div class="link-item">' | Out-File -FilePath index.html -Append -Encoding UTF8
          '            <a href="./coverage/index.html">ðŸ“Š Test Coverage Report</a>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '        </div>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '    </div>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '</body>' | Out-File -FilePath index.html -Append -Encoding UTF8
          '</html>' | Out-File -FilePath index.html -Append -Encoding UTF8
          
          # doc and specification directories already created above if openapi.json exists
        } else {
          # If no docs (Swagger/OpenAPI), use coverage as root
          Copy-Item -Recurse ../private/coverage/* .
        }
        
        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"
        
        # Commit and push
        git add -A
        git commit -m "Deploy to GitHub Pages"
        git push origin gh-pages --force
        
        # Cleanup
        cd $env:TEMP
        Start-Sleep -Seconds 3
        Remove-Item -Recurse -Force $tempDir -ErrorAction SilentlyContinue